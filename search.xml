<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二叉树算法学习一]]></title>
    <url>%2F2019%2F12%2F25%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[顾名思义, 二叉树结构就是一个结点上面最多有两个子节点的树状数据结构. 节点有左右次序之分.树结构数据有一些专有名词: 来源 百度百科 结点层: 根结点的层定义为1, 根结点的孩子节点为2, 以此类推树的深度: 树中最大的结点层结点的度: 结点的子结点的个数树的度: 树中最大的结点度叶子结点: 也叫终端结点, 是度为0的结点分枝结点: 度不为0的结点有序树: 子树有序的树无序树: 不考虑子树的顺序 二叉树的性质: 在非空二叉树中, 第i层的结点数不超过math.pow(2, i-1), i&gt;=1 深度为h的二叉树最多有math.pow(2, h - 1)个结点, 最少有h个结点(剩下的特性自己去百度看了…) 二叉树结点的数据结构:链表存储方式的结构, 不能直接拿到结点的数据, 需要一个一个的搜索 123456local bitNode = &#123; data = xxx, -- 结点中存放的数据 lChild = bitNode, -- 左边子结点 rChild = bitNode, -- 右边子结点 parent = parent, -- 父结点(根结点的父结点为空)&#125; 递归生成二叉树数据的方法: 1234567891011121314151617-- bTree 生成的二叉树数据的table-- treeCount 需要生成深度为多少的二叉树function createBitNode(bTree, nodeCount, parent) if nodeCount &gt; 0 then bTree.data = nodeCount bTree.lChild = &#123;&#125; bTree.rChild = &#123;&#125; bTree.parent = parent createBitNode(bTree.lChild, nodeCount - 1, bTree) createBitNode(bTree.rChild, nodeCount - 1, bTree) endendlocal bTree = &#123;&#125;local nodeCount = 3createBitNode(bTree, nodeCount) 一般来说, 遍历二叉树结构的方法有三种, 先序遍历(DLR), 中序遍历(LDR), 后序遍历区别在于操作根节点的数据(data)的顺序先序遍历: 12345678910function preTreeParse(bTree) -- 这里只是用data字段是否有值来判断结点是否为空, 正常情况下用next(bTree)判断就好 if bTree.data then print(bTree.data) preTreeParse(bTree.lChild) preTreeParse(bTree.rChild) endendpreTreeParse(bTree) 中序遍历: 12345678910function midTreeParse(bTree) -- 这里只是用data字段是否有值来判断结点是否为空, 正常情况下用next(bTree)判断就好 if bTree.data then midTreeParse(bTree.lChild) print(bTree.data) midTreeParse(bTree.rChild) endendmidTreeParse(bTree) 后序遍历 12345678910function lastTreeParse(bTree) -- 这里只是用data字段是否有值来判断结点是否为空, 正常情况下用next(bTree)判断就好 if bTree.data then lastTreeParse(bTree.lChild) lastTreeParse(bTree.rChild) print(bTree.data) endendlastTreeParse(bTree)]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webview不能播放视频和声音的问题分析]]></title>
    <url>%2F2019%2F12%2F25%2Fwebview%E4%B8%8D%E8%83%BD%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91%E5%92%8C%E5%A3%B0%E9%9F%B3%E7%9A%84%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[webview打开网页后不能播放视频和声音, 有以下几种情况. 没打开硬件加速: 在manifest.xml文件的cocos2dx的activity内加上 1android:hardwareAccelerated=&quot;true&quot; 在AppActivity.java文件的onCreate方法内加上 1getWindow().setFlags(WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED, WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED); 在Cocos2dxWebView.java的public Cocos2dxWebView(xxx,xxx) 方法内添加 1this.setLayerType(View.LAYER_TYPE_HARDWARE, null); 没打开js语法应用: 在Cocos2dxWebView.java的public Cocos2dxWebView(xxx,xxx) 方法内添加 1this.getSettings().setJavaScriptEnabled(true); 没打开dom: 在Cocos2dxWebView.java的public Cocos2dxWebView(xxx,xxx) 方法内添加 1this.getSettings().setDomStorageEnabled(true); 没打开视频自动播放控制: 在Cocos2dxWebView.java的public Cocos2dxWebView(xxx,xxx) 方法内添加 1this.getSettings().setMediaPlaybackRequiresUserGesture(false); 如果其上方法都没能解决, 请继续google/baidu/github/leecode/csdn ====]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单顺时针算法的实现]]></title>
    <url>%2F2019%2F12%2F25%2F%E7%AE%80%E5%8D%95%E9%A1%BA%E6%97%B6%E9%92%88%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[最近在制作简易刚体描点工具的时候为了将点顺时针排列为烦恼,想了好多算法模型都不能解决问题, 今天突然来了灵感有了两个算法方案 将点按照y轴映射到圆上, 计算映射的点在圆上的弧度, 比较映射的点的弧度, 即可知道先后顺序 按照象限进行点的排列, 第一/四象限按照y轴从上往下排, 第二/三象限按照y轴从下往上排, 这个算法模型参照的是机器扫描原理, 就如机器人一样选取一个轴(X,Y)进行递增式扫描, 将扫描到的数据进行分析归纳后就得出简单结果 下面是第二个方案的具体实现逻辑: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586local function quadSort1(tab) table.sort(tab, function(a, b) if a[2] &gt; b[2] then return true elseif a[2] == b[2] then return (a[1] &lt; b[2]) end end)endlocal function quadSort4(tab) table.sort(tab, function(a, b) if a[2] &gt; b[2] then return true elseif a[2] == b[2] then return (a[1] &gt; b[2]) end end)endlocal function quadSort3(tab) table.sort(tab, function(a, b) if a[2] &lt; b[2] then return true elseif a[2] == b[2] then return (a[1] &gt; b[2]) end end)endlocal function quadSort2(tab) table.sort(tab, function(a, b) if a[2] &lt; b[2] then return true elseif a[2] == b[2] then return (a[1] &lt; b[2]) end end)endlocal function clockwiseSort(tab) local quad = &#123;&#125; for i = 1, 4 do quad[i] = &#123;&#125; end for k,v in ipairs(tab) do if v[1] &lt; 0 and v[2] &gt;= 0 then table.insert(quad[2], v) elseif v[1] &gt;= 0 and v[2] &gt; 0 then table.insert(quad[1], v) elseif v[1] &gt; 0 and v[2] &lt;= 0 then table.insert(quad[4], v) elseif v[1] &lt;= 0 and v[2] &lt; 0 then table.insert(quad[3], v) end end quadSort1(quad[1]) quadSort2(quad[2]) quadSort3(quad[3]) quadSort4(quad[4]) local count = 1 for k,v in ipairs(quad[2]) do tab[count] = v count = count + 1 end for k,v in ipairs(quad[1]) do tab[count] = v count = count + 1 end for k,v in ipairs(quad[4]) do tab[count] = v count = count + 1 end for k,v in ipairs(quad[3]) do tab[count] = v count = count + 1 endendclockwiseSort(tab)]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何快速进行lua表的制作]]></title>
    <url>%2F2019%2F12%2F24%2F%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E8%BF%9B%E8%A1%8Clua%E8%A1%A8%E7%9A%84%E5%88%B6%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[在日常的开发中, 或多或少会遇到将大量的, 需要初始化的数据制作到luatable里面,将花费很多的精力, 还往往由于打错字、打错标点符号浪费了大量的时间.经过一段时间的思考, 决定编写一个工具来配合excel表进行制作这类的大量的重复的数据由于现在项目都是android和ios并行开发, 隧使用python语言进行工具的编写, 下面贴出python代码:(如果缺少xlrd库的话 pip install xlrd) 代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132# -- coding: utf-8 --import sysreload(sys)sys.setdefaultencoding( &quot;utf-8&quot; )import osimport xlrdimport recur_path = os.path.abspath(sys.argv[0] + &quot;/../&quot;)# 分析一个表的内容# sheetObject 工作表的对象def parseOneSheet(excel_sheet): # excel data dict excel_data_dict = &#123;&#125; # col name list col_name_list = [] #col val type list col_val_type_list = [] # ctype: 0 empty, 1 string, 2 number, 3 date, 4 boolean, 5 error #value名字 比如 id desc for col in range(0, excel_sheet.ncols): cell = excel_sheet.cell(1, col) col_name_list.append(str(cell.value)) assert cell.ctype == 1, &quot;found a invalid col name in col [%d] !~&quot; % (col) #value的类型 比如int string boolean啊 for col in range(0, excel_sheet.ncols): cell = excel_sheet.cell(2, col) col_val_type_list.append(str(cell.value)) assert cell.ctype == 1, &quot;found a invalid col val type in col [%d] !~&quot; % (col) #遍历所有有效的行 for row in range(3, excel_sheet.nrows): cell_id = excel_sheet.cell(row, 0) assert cell_id.ctype == 2, &quot;found a invalid id in row [%d] !~&quot; % (row) if cell_id.value in excel_data_dict: print(&apos;[警告] 配置了相同的&quot;%d&quot;物品, 请做检查&apos; % (cell_id.value)) print(&apos;[警告] 配置了相同的&quot;%d&quot;物品, 请做检查&apos; % (cell_id.value)) print(&apos;[警告] 配置了相同的&quot;%d&quot;物品, 请做检查&apos; % (cell_id.value)) # row data list row_data_list = [] for col in range(0, excel_sheet.ncols): cell = excel_sheet.cell(row, col) k = col_name_list[col] cell_val_type = col_val_type_list[col] # ignored the string that start with &apos;_&apos; if str(k).startswith(&apos;#&apos;): continue if cell_val_type == &apos;string&apos;: if cell.ctype == 0: v = &apos;\&apos;\&apos;&apos; else: v = &apos;\&apos;%s\&apos;&apos; % (cell.value) elif cell_val_type == &apos;int&apos;: if cell.ctype == 0: v = -1 else: v = int(cell.value) elif cell_val_type == &apos;float&apos;: if cell.ctype == 0: v = -1 else: v = float(cell.value) elif cell_val_type == &apos;table&apos;: if cell.ctype == 0: v = &apos;&#123;&#125;&apos; else: v = cell.value else: v = cell.value row_data_list.append([k, v]) excel_data_dict[cell_id.value] = row_data_list return excel_data_dictdef excel2lua(src_excel_path, tgt_lua_path): # print(&apos;[file] %s -&gt; %s&apos; % (src_excel_path, tgt_lua_path)) # load excel data excel_data_src = xlrd.open_workbook(src_excel_path, encoding_override = &apos;utf-8&apos;) for name in excel_data_src.sheet_names(): print(&quot;Worksheet name %s &quot; % name) data_dict = parseOneSheet(excel_data_src.sheet_by_name(name)) lua_path = tgt_lua_path + name + &quot;.lua&quot; lua_export_file = open(lua_path, &quot;w&quot;) lua_export_file.write(&apos;local %s = &#123;\n&apos; % name) for k, v in data_dict.items(): lua_export_file.write(&apos; [%d] = &#123;\n&apos; % k) for row_data in v: lua_export_file.write(&apos; &#123;0&#125; = &#123;1&#125;,\n&apos;.format(row_data[0], row_data[1])) lua_export_file.write(&apos; &#125;,\n&apos;) lua_export_file.write(&apos;&#125;\n&apos;) lua_export_file.write(&apos;return %s&apos; % name) lua_export_file.close()if __name__ == &apos;__main__&apos;: in_path = &quot;&quot; out_path = &quot;&quot; if len(sys.argv) == 1: print(&apos;未检测到内容,采用默认路径&apos;) in_path = cur_path + &quot;/in/&quot; out_path = cur_path + &quot;/out/&quot; else: # excel文件的文件夹地址 默认为同目录下的in文件夹 in_path = sys.argv[1] # 输出到lua的文件夹地址 默认为同目录下的in文件夹 out_path = sys.argv[2] print(&quot;输入目录为 %s, 输出目录为%s\n&quot; % (in_path, out_path)) for root, dirs, files in os.walk(in_path): for name in files: if( &quot;.xls&quot; in name and &quot;.xlsx&quot; in name ): print(root + name) excel2lua(root + name, out_path) exit(0) 代码从一位网友的blog找到的, 权侵删.]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间复杂度与空间复杂度的个人见解]]></title>
    <url>%2F2019%2F06%2F24%2F%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E4%B8%AA%E4%BA%BA%E8%A7%81%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[最近在回顾大学时代算法导论说的空间复杂度与实践复杂度问题, 今天偶有所悟, 写下来防止以后忘记也好. 时间复杂度: 按照百度百科的说法是 定型的描述一个算法的运行时间, 用O()来表示 其实嘛, 直接常规来计算就是这个算法里面进行了几次计算, 比如单纯的 local a = tab[1], 就是一次 for k,v in ipairs(tab) do local a = v end 就是n(n = #tab) 次, for k,v in ipairs(tab) do for key, value in ipairs(v) do local a = value end end 就是n²(#tab * #v)次 这样子一看 就通俗易懂很多了… 代码进行了几次运算就有, 总运算次数能用哪类函数来表示, 就是写为O(1) O(nlgn) O(n²) O(n³)的空间复杂度 运行时间 O(1) &lt; O(n) &lt; O(nlgn) &lt; O(n²) &lt; O(n³) &lt; O(n!) , 越靠后运行时间越长, 算法效率越低 “一套图 搞懂“时间复杂度”]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[归并排序算法的lua实现]]></title>
    <url>%2F2019%2F06%2F24%2F%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84lua%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758-- 归并排序算法学习--[[ 1. 设置临时table, 用来存放排序之后的数组 2. 设定两个值i,j, 初始值分别为两个待排序数组的第一个key 3. 比较key为i,j对应的值, 较小的放入合并空间, 并移动到下一个值 4. 重复步骤3到i,j其中一个超出数组最大值 5. 将另一个数组的剩下的元素复制到临时table中]]function merge(sourTab, tmpTab, startIndex, midIndex, endIndex) local i = startIndex local j = midIndex + 1 local k = startIndex while(i &lt;= midIndex and j &lt;= endIndex) do if sourTab[i] &gt; sourTab[j] then tmpTab[k] = sourTab[j] j = j + 1 else tmpTab[k] = sourTab[i] i = i + 1 end k = k + 1 end -- 将剩下的拼到临时table的末尾 理论上i, j只有一个剩下 while (i &lt;= midIndex) do tmpTab[k] = sourTab[i] k = k + 1 i = i + 1 end -- 将剩下的拼到临时table的末尾 while (j &lt;= endIndex) do tmpTab[k] = sourTab[j] k = k + 1 j = j + 1 end -- 将排序好的数组赋值回原table, 这一步不能省略 for i = startIndex, endIndex do sourTab[i] = tmpTab[i] endendfunction mergeSort(sourTab, tmpTab, startIndex, endIndex) if startIndex &lt; endIndex then local midIndex = startIndex + math.floor((endIndex - startIndex) / 2) mergeSort(sourTab, tmpTab, startIndex, midIndex) mergeSort(sourTab, tmpTab, midIndex + 1, endIndex) merge(sourTab, tmpTab, startIndex, midIndex, endIndex) endendlocal tab = &#123;50, 10, 20, 30, 70, 40, 80, 60&#125;local tab1 = &#123;&#125;mergeSort(tab, tab1, 1, #tab)print(table.concat(tab, &quot;,&quot;)) 参考百度百科]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序算法的lua实现]]></title>
    <url>%2F2019%2F06%2F24%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84lua%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556-- 快速排序算法的实现--[[ 设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它左边，所有比它大的数都放到它右边，这个过程称为一趟快速排序。值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。 一趟快速排序的算法是： 1）设置两个变量i、j，排序开始的时候：i=1，j=N-1； 2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]； 3）从j开始向前搜索，即由后开始向前搜索(j--)，找到第一个小于key的值A[j] 4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i] 5) 将A[j]与A[i]的值互换 6）重复第3、4、5步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。]]function Qsort(tab, left, right) if right &lt;= left then return end local i = left + 1 local j = right local key = tab[left] while true do -- 从左往右找比key大的值 while (tab[i] &lt; key) do i = i + 1 if i == right then break end end -- 从右往左找比key小的值 while (tab[j] &gt; key) do j = j - 1 if j == left then break end end if i &gt;= j then break end local tmp = tab[i] tab[i] = tab[j] tab[j] = tmp end tab[left] = tab[j] tab[j] = key Qsort(tab, left, j - 1) Qsort(tab, j + 1, right)endlocal tab = &#123;6,2,7,3,8,9&#125;-- local tab = &#123;5, 4, 3, 2, 1&#125;Qsort(tab, 1, #tab)for k,v in ipairs(tab) do print(k,v)end]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给鱼添加简单阴影第二种方法]]></title>
    <url>%2F2019%2F06%2F21%2F%E7%BB%99%E9%B1%BC%E6%B7%BB%E5%8A%A0%E7%AE%80%E5%8D%95%E9%98%B4%E5%BD%B1%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[直接采用renderTexture实现, 只是阴影没有层次的区别, 适合静态使用 123456789101112131415161718192021222324252627282930local ShadowLayer = class(&quot;ShadowLayer&quot;, ccui.Layout)function ShadowLayer:ctor(target, root) self.target = target local size = cc.Director:getInstance():getWinSize() self:setContentSize(cc.size(size.width, size.height)) self:setAnchorPoint(cc.p(0,0)) self:setPosition(cc.p(-15, 0)) self.pRender = cc.RenderTexture:create(size.width, size.height, cc.TEXTURE2_D_PIXEL_FORMAT_RGB_A8888) self.pRender:setPosition(cc.p(size.width / 2, size.height / 2)) self.pRender:getSprite():setBlendFunc(cc.blendFunc(GL_ZERO, GL_ONE_MINUS_SRC_ALPHA)) self.pRender:getSprite():setOpacity(150) self.pRender:addTo(self) self.pRender:retain() self:scheduleUpdateWithPriorityLua(handler(self, self.update), 0.1)endfunction ShadowLayer:update(dt) self.pRender:clear(0, 0, 0, 0) self.pRender:begin() self.target:visit() self.pRender:endToLua()endfunction ShadowLayer:setShadowColor(color) self.pRender:clear(color.r, color.g, color.b, color.a)endreturn ShadowLayer 原理是将鱼的layer渲染到renderTexture下, 然后改变renderTexture内的sprite的混色方案, 得到黑色阴影 只是有个bug, 会闪退, 由于本人对opengl研究较少, 暂时没查出什么问题 慎用此方法]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如果给鱼添加简单阴影]]></title>
    <url>%2F2019%2F06%2F21%2F%E5%A6%82%E6%9E%9C%E7%BB%99%E9%B1%BC%E6%B7%BB%E5%8A%A0%E7%AE%80%E5%8D%95%E9%98%B4%E5%BD%B1%2F</url>
    <content type="text"><![CDATA[捕鱼项目里, 经常应策划需求要添加一个简单的阴影因为我们项目里面鱼是2d的, 理论上在鱼的底下添加一个同外形的黑色的鱼就可以达到这个效果基于此思路, 在鱼的文件内添加一个 schduler 每0.2秒执行一遍渲染下面是代码: 1234567891011121314151617181920function FishBase:initShadowUpdate() self.shadowSp = cc.Sprite:create() self.shadowSp:initWithSpriteFrameName(&quot;fishFrameName.png&quot;) -- 自行添加自己鱼的frameName self.shadowSp:setBlendFunc(cc.blendFunc(GL_ZERO, GL_ONE_MINUS_SRC_ALPHA)) -- 这个地方自行百度 self.shadowSp:setOpacity(150) self.shadowSp:setPosition(cc.p(-10, 0)) self.shadowSp:addTo(self, -1) self.shadowSp:scheduleUpdateWithPriorityLua(handler(self, self.shadowUpdate), 0.1)endfunction FishBase:shadowUpdate(dt) self.shadowSp:initWithSpriteFrame(self.aniSp:getSpriteFrame()) -- self.aniSp 为鱼的sprite self.shadowSp:setOpacity(150) --这里必须先设置不透明度, 不然setBlendFunc之后不再渲染透明度 self.shadowSp:setBlendFunc(cc.blendFunc(GL_ZERO, GL_ONE_MINUS_SRC_ALPHA)) -- 这里的计算是假设光源在右边, 且是方向光 local x = math.sin(math.rad(self:getRotation() - 90)) * 15 local y = - math.cos(math.rad(self:getRotation() - 90)) * 15 self.shadowSp:setPosition(cc.p(x, y))end 用setBlendFunc比直接用opengl更简单一些, 不需要自己写opengl文件, 直接混色就能达到要求了]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[捕鱼项目减少cpu占用的优化方案总结]]></title>
    <url>%2F2019%2F06%2F21%2F%E6%8D%95%E9%B1%BC%E9%A1%B9%E7%9B%AE%E5%87%8F%E5%B0%91cpu%E5%8D%A0%E7%94%A8%E7%9A%84%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[最近在做捕鱼项目的时候, 总为房间内cpu占用率过高而烦恼, cpu占用率甚至达到了60%, 着手优化这部分内容重中之重为了优化代码 减少cpu占用率 采用以下流程检查代码那部分导致cpu占用率增加 在 config.lua 文件内将 CC_SHOW_FPS 设置为 true , 显示整个游戏的GL verts(当前页面顶点数), GL call(每帧调用OpenGl次数), FPS(帧率) 1.1 MAC模拟器上GL verts 8000+, GL call 200+, FPS 58+ 1.2 理论上FPS 58+不影响游戏的流畅度, 但是GL verts 和 GL call 太高了, 需要优化 经检查代码发现: 2.1 为了实现鱼的可点击, 每条鱼身上都添加了一张白图作为点击对象 2.2 为了实现光影效果, 每条鱼身上添加了一个 scheduler 每0.2秒渲染一个阴影到鱼的底下, (如果给鱼添加简单阴影) 分析上面两个方案的弊端 3.1 添加了白图作为点击对象, GL verts 增加了2000+ 3.2 添加了光影效果, GL verts 增加了2000+ GL call 增加了100+ 对这两方案进行优化 4.1 由于鱼的碰撞采用的是cocos2dx 的物理世界(physicsWorld)的oncontactBegin方法, 那鱼的点击, 可以采用以下物理世界里面的getShape方法实现, 具体代码: 12345678function xxx:onTouchEnded(touch, event) local physicsWorld = cc.Director:getInstance():getRunningScene():getPhysicsWorld() local shape = physicsWorld:getShape(touch:getLocation()) if shape then local node = shape:getBody():getNode() -- 这里获取到了当前点击的Node, 自行判断是否为鱼即可 endend getShape方法优先获取 最上层的shape(为了碰撞设置的多边形) 无需自行判断那条鱼在最上面. 如果需要知道当前点击位置附近有多少条鱼, 建议采用getShapes(touch:getLocation())方法 4.2 光影效果直接删掉或者给个按钮用户选择是否出现即可(浪费了我研究这么久) 做完以上优化之后发现 Gl verts 还要3000+, 检查代码发现, 捕鱼的房间直接add到大厅上面的, 还需要将大厅setVisible(false)掉 因为cocos2dx很多layer(layout)叠在一起时, 只要可见都会进行渲染, 凭空浪费cpu 结论: 做cpu优化时, 打开fps显示, 检查代码的哪一部分会导致 GL verts, GL call 升高, 并找替代方法, 可以达成目标]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo怎么添加本地搜索功能]]></title>
    <url>%2F2019%2F06%2F20%2Fhexo%E6%80%8E%E4%B9%88%E6%B7%BB%E5%8A%A0%E6%9C%AC%E5%9C%B0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD%E7%9A%84%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[在blog主文件夹内将searchdb插件安装进来 npm install hexo-generator-searchdb –save mac下如果出现gym错误 access deny错误的话, 在blog主文件夹内运行 sudo chown -R $USER ./ 目的是将blog的归属改为当前用户, 当前用户拥有归属权的时候就不会出现权限问题 在站点配置文件_config.yml文件下添加 search: path: search.xml field: post format: html limit: 10000 目的是在public文件夹内生成search.xml文件, 将所有发不过的文件形成链接放入search.xml内, 这样子就有了搜索的能力 在主题配置文件_config.yml文件内找到 local_search: enable: false trigger: auto top_n_per_article: 1 将false改为true, 如果本来就是true就做理会, 如果没有上面这段代码就添加上去 由于页面配置原因, 就不把注释的部分贴进来了, 请自行脑补 在blog主文件内执行一次 hexo g 这样子你的博客就拥有了本地搜索功能了]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于hexo怎么建立分配和标签的笔记]]></title>
    <url>%2F2019%2F06%2F20%2F%E5%85%B3%E4%BA%8Ehexo%E6%80%8E%E4%B9%88%E5%BB%BA%E7%AB%8B%E5%88%86%E9%85%8D%E5%92%8C%E6%A0%87%E7%AD%BE%E7%9A%84%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[站点配置文件中将language改为zh-Hans(因为我的主题里面的中文样式是这个) 主题配置文件中将language改为zh-Hans 主题配置文件中在menu: 选项内把home(主页) tags(标签) categories(分配) archives(归档) 前面的#去掉 在blog主文件下 hexo new page tags (这样就新建了标签分页) 在blog主文件下 hexo new page categories (这样子就新建了分类分页) 这样子你就有了各个分页的功能 目前来说主页和各个分页的内容都存放在_posts文件夹内]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[主页]]></title>
    <url>%2F2019%2F06%2F20%2F%E4%B8%BB%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[欢迎来到龙中之马的博客]]></content>
  </entry>
  <entry>
    <title><![CDATA[第一篇笔记]]></title>
    <url>%2F2019%2F06%2F20%2F%E7%AC%AC%E4%B8%80%E7%AF%87%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[这是我的第一篇博客文章,虽然弄的很垃圾,但是也勉强把私人博客弄起来了.期待以后的写作.]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇随感]]></title>
    <url>%2F2019%2F06%2F20%2F%E7%AC%AC%E4%B8%80%E7%AF%87%E9%9A%8F%E6%84%9F%2F</url>
    <content type="text"><![CDATA[用这个博客工具还是挺有意思的, 虽然现在才会弄一点点, 连引用别人的文章之类的都没学会但是起码弄起来了, 挺感慨工作四年了都没想起弄个博客来记录日常工作的点点滴滴, 没进行自己的技术积累, 有一种荒废青春的感觉. 也是几天前才想起有弄个博客记录的必要, 因为儿子已经7个月, 生活的重担让我有了危机感,不能像刚毕业的那段日子一样每天得过且过, 需要拥有一点自己的优势, 得以在未来的工作中不被淘汰, 给我自己的这个小家更多的支持. 在这里也感谢我的老婆给与我奋发向前的动力. 在以后的日子里, 这个博客会随着我的成长慢慢完善. 慢慢打造自己的小优势. ^_^]]></content>
      <tags>
        <tag>随感</tag>
      </tags>
  </entry>
</search>
