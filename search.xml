<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[归并排序算法的lua实现]]></title>
    <url>%2F2019%2F06%2F24%2F%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84lua%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758-- 归并排序算法学习--[[ 1. 设置临时table, 用来存放排序之后的数组 2. 设定两个值i,j, 初始值分别为两个待排序数组的第一个key 3. 比较key为i,j对应的值, 较小的放入合并空间, 并移动到下一个值 4. 重复步骤3到i,j其中一个超出数组最大值 5. 将另一个数组的剩下的元素复制到临时table中]]function merge(sourTab, tmpTab, startIndex, midIndex, endIndex) local i = startIndex local j = midIndex + 1 local k = startIndex while(i &lt;= midIndex and j &lt;= endIndex) do if sourTab[i] &gt; sourTab[j] then tmpTab[k] = sourTab[j] j = j + 1 else tmpTab[k] = sourTab[i] i = i + 1 end k = k + 1 end -- 将剩下的拼到临时table的末尾 理论上i, j只有一个剩下 while (i &lt;= midIndex) do tmpTab[k] = sourTab[i] k = k + 1 i = i + 1 end -- 将剩下的拼到临时table的末尾 while (j &lt;= endIndex) do tmpTab[k] = sourTab[j] k = k + 1 j = j + 1 end -- 将排序好的数组赋值回原table, 这一步不能省略 for i = startIndex, endIndex do sourTab[i] = tmpTab[i] endendfunction mergeSort(sourTab, tmpTab, startIndex, endIndex) if startIndex &lt; endIndex then local midIndex = startIndex + math.floor((endIndex - startIndex) / 2) mergeSort(sourTab, tmpTab, startIndex, midIndex) mergeSort(sourTab, tmpTab, midIndex + 1, endIndex) merge(sourTab, tmpTab, startIndex, midIndex, endIndex) endendlocal tab = &#123;50, 10, 20, 30, 70, 40, 80, 60&#125;local tab1 = &#123;&#125;mergeSort(tab, tab1, 1, #tab)print(table.concat(tab, &quot;,&quot;)) 参考百度百科]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序算法的lua实现]]></title>
    <url>%2F2019%2F06%2F24%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84lua%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556-- 快速排序算法的实现--[[ 设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它左边，所有比它大的数都放到它右边，这个过程称为一趟快速排序。值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。 一趟快速排序的算法是： 1）设置两个变量i、j，排序开始的时候：i=1，j=N-1； 2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]； 3）从j开始向前搜索，即由后开始向前搜索(j--)，找到第一个小于key的值A[j] 4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i] 5) 将A[j]与A[i]的值互换 6）重复第3、4、5步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。]]function Qsort(tab, left, right) if right &lt;= left then return end local i = left + 1 local j = right local key = tab[left] while true do -- 从左往右找比key大的值 while (tab[i] &lt; key) do i = i + 1 if i == right then break end end -- 从右往左找比key小的值 while (tab[j] &gt; key) do j = j - 1 if j == left then break end end if i &gt;= j then break end local tmp = tab[i] tab[i] = tab[j] tab[j] = tmp end tab[left] = tab[j] tab[j] = key Qsort(tab, left, j - 1) Qsort(tab, j + 1, right)endlocal tab = &#123;6,2,7,3,8,9&#125;-- local tab = &#123;5, 4, 3, 2, 1&#125;Qsort(tab, 1, #tab)for k,v in ipairs(tab) do print(k,v)end]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给鱼添加简单阴影第二种方法]]></title>
    <url>%2F2019%2F06%2F21%2F%E7%BB%99%E9%B1%BC%E6%B7%BB%E5%8A%A0%E7%AE%80%E5%8D%95%E9%98%B4%E5%BD%B1%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[直接采用renderTexture实现, 只是阴影没有层次的区别, 适合静态使用 123456789101112131415161718192021222324252627282930local ShadowLayer = class(&quot;ShadowLayer&quot;, ccui.Layout)function ShadowLayer:ctor(target, root) self.target = target local size = cc.Director:getInstance():getWinSize() self:setContentSize(cc.size(size.width, size.height)) self:setAnchorPoint(cc.p(0,0)) self:setPosition(cc.p(-15, 0)) self.pRender = cc.RenderTexture:create(size.width, size.height, cc.TEXTURE2_D_PIXEL_FORMAT_RGB_A8888) self.pRender:setPosition(cc.p(size.width / 2, size.height / 2)) self.pRender:getSprite():setBlendFunc(cc.blendFunc(GL_ZERO, GL_ONE_MINUS_SRC_ALPHA)) self.pRender:getSprite():setOpacity(150) self.pRender:addTo(self) self.pRender:retain() self:scheduleUpdateWithPriorityLua(handler(self, self.update), 0.1)endfunction ShadowLayer:update(dt) self.pRender:clear(0, 0, 0, 0) self.pRender:begin() self.target:visit() self.pRender:endToLua()endfunction ShadowLayer:setShadowColor(color) self.pRender:clear(color.r, color.g, color.b, color.a)endreturn ShadowLayer 原理是将鱼的layer渲染到renderTexture下, 然后改变renderTexture内的sprite的混色方案, 得到黑色阴影 只是有个bug, 会闪退, 由于本人对opengl研究较少, 暂时没查出什么问题 慎用此方法]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如果给鱼添加简单阴影]]></title>
    <url>%2F2019%2F06%2F21%2F%E5%A6%82%E6%9E%9C%E7%BB%99%E9%B1%BC%E6%B7%BB%E5%8A%A0%E7%AE%80%E5%8D%95%E9%98%B4%E5%BD%B1%2F</url>
    <content type="text"><![CDATA[捕鱼项目里, 经常应策划需求要添加一个简单的阴影因为我们项目里面鱼是2d的, 理论上在鱼的底下添加一个同外形的黑色的鱼就可以达到这个效果基于此思路, 在鱼的文件内添加一个 schduler 每0.2秒执行一遍渲染下面是代码: 1234567891011121314151617181920function FishBase:initShadowUpdate() self.shadowSp = cc.Sprite:create() self.shadowSp:initWithSpriteFrameName(&quot;fishFrameName.png&quot;) -- 自行添加自己鱼的frameName self.shadowSp:setBlendFunc(cc.blendFunc(GL_ZERO, GL_ONE_MINUS_SRC_ALPHA)) -- 这个地方自行百度 self.shadowSp:setOpacity(150) self.shadowSp:setPosition(cc.p(-10, 0)) self.shadowSp:addTo(self, -1) self.shadowSp:scheduleUpdateWithPriorityLua(handler(self, self.shadowUpdate), 0.1)endfunction FishBase:shadowUpdate(dt) self.shadowSp:initWithSpriteFrame(self.aniSp:getSpriteFrame()) -- self.aniSp 为鱼的sprite self.shadowSp:setOpacity(150) --这里必须先设置不透明度, 不然setBlendFunc之后不再渲染透明度 self.shadowSp:setBlendFunc(cc.blendFunc(GL_ZERO, GL_ONE_MINUS_SRC_ALPHA)) -- 这里的计算是假设光源在右边, 且是方向光 local x = math.sin(math.rad(self:getRotation() - 90)) * 15 local y = - math.cos(math.rad(self:getRotation() - 90)) * 15 self.shadowSp:setPosition(cc.p(x, y))end 用setBlendFunc比直接用opengl更简单一些, 不需要自己写opengl文件, 直接混色就能达到要求了]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[捕鱼项目减少cpu占用的优化方案总结]]></title>
    <url>%2F2019%2F06%2F21%2F%E6%8D%95%E9%B1%BC%E9%A1%B9%E7%9B%AE%E5%87%8F%E5%B0%91cpu%E5%8D%A0%E7%94%A8%E7%9A%84%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[最近在做捕鱼项目的时候, 总为房间内cpu占用率过高而烦恼, cpu占用率甚至达到了60%, 着手优化这部分内容重中之重为了优化代码 减少cpu占用率 采用以下流程检查代码那部分导致cpu占用率增加 在 config.lua 文件内将 CC_SHOW_FPS 设置为 true , 显示整个游戏的GL verts(当前页面顶点数), GL call(每帧调用OpenGl次数), FPS(帧率) 1.1 MAC模拟器上GL verts 8000+, GL call 200+, FPS 58+ 1.2 理论上FPS 58+不影响游戏的流畅度, 但是GL verts 和 GL call 太高了, 需要优化 经检查代码发现: 2.1 为了实现鱼的可点击, 每条鱼身上都添加了一张白图作为点击对象 2.2 为了实现光影效果, 每条鱼身上添加了一个 scheduler 每0.2秒渲染一个阴影到鱼的底下, (如果给鱼添加简单阴影) 分析上面两个方案的弊端 3.1 添加了白图作为点击对象, GL verts 增加了2000+ 3.2 添加了光影效果, GL verts 增加了2000+ GL call 增加了100+ 对这两方案进行优化 4.1 由于鱼的碰撞采用的是cocos2dx 的物理世界(physicsWorld)的oncontactBegin方法, 那鱼的点击, 可以采用以下物理世界里面的getShape方法实现, 具体代码: 12345678function xxx:onTouchEnded(touch, event) local physicsWorld = cc.Director:getInstance():getRunningScene():getPhysicsWorld() local shape = physicsWorld:getShape(touch:getLocation()) if shape then local node = shape:getBody():getNode() -- 这里获取到了当前点击的Node, 自行判断是否为鱼即可 endend getShape方法优先获取 最上层的shape(为了碰撞设置的多边形) 无需自行判断那条鱼在最上面. 如果需要知道当前点击位置附近有多少条鱼, 建议采用getShapes(touch:getLocation())方法 4.2 光影效果直接删掉或者给个按钮用户选择是否出现即可(浪费了我研究这么久) 做完以上优化之后发现 Gl verts 还要3000+, 检查代码发现, 捕鱼的房间直接add到大厅上面的, 还需要将大厅setVisible(false)掉 因为cocos2dx很多layer(layout)叠在一起时, 只要可见都会进行渲染, 凭空浪费cpu 结论: 做cpu优化时, 打开fps显示, 检查代码的哪一部分会导致 GL verts, GL call 升高, 并找替代方法, 可以达成目标]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo怎么添加本地搜索功能]]></title>
    <url>%2F2019%2F06%2F20%2Fhexo%E6%80%8E%E4%B9%88%E6%B7%BB%E5%8A%A0%E6%9C%AC%E5%9C%B0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD%E7%9A%84%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[在blog主文件夹内将searchdb插件安装进来 npm install hexo-generator-searchdb –save mac下如果出现gym错误 access deny错误的话, 在blog主文件夹内运行 sudo chown -R $USER ./ 目的是将blog的归属改为当前用户, 当前用户拥有归属权的时候就不会出现权限问题 在站点配置文件_config.yml文件下添加 search: path: search.xml field: post format: html limit: 10000 目的是在public文件夹内生成search.xml文件, 将所有发不过的文件形成链接放入search.xml内, 这样子就有了搜索的能力 在主题配置文件_config.yml文件内找到 local_search: enable: false trigger: auto top_n_per_article: 1 将false改为true, 如果本来就是true就做理会, 如果没有上面这段代码就添加上去 由于页面配置原因, 就不把注释的部分贴进来了, 请自行脑补 在blog主文件内执行一次 hexo g 这样子你的博客就拥有了本地搜索功能了]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于hexo怎么建立分配和标签的笔记]]></title>
    <url>%2F2019%2F06%2F20%2F%E5%85%B3%E4%BA%8Ehexo%E6%80%8E%E4%B9%88%E5%BB%BA%E7%AB%8B%E5%88%86%E9%85%8D%E5%92%8C%E6%A0%87%E7%AD%BE%E7%9A%84%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[站点配置文件中将language改为zh-Hans(因为我的主题里面的中文样式是这个) 主题配置文件中将language改为zh-Hans 主题配置文件中在menu: 选项内把home(主页) tags(标签) categories(分配) archives(归档) 前面的#去掉 在blog主文件下 hexo new page tags (这样就新建了标签分页) 在blog主文件下 hexo new page categories (这样子就新建了分类分页) 这样子你就有了各个分页的功能 目前来说主页和各个分页的内容都存放在_posts文件夹内]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[主页]]></title>
    <url>%2F2019%2F06%2F20%2F%E4%B8%BB%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[欢迎来到龙中之马的博客]]></content>
  </entry>
  <entry>
    <title><![CDATA[第一篇笔记]]></title>
    <url>%2F2019%2F06%2F20%2F%E7%AC%AC%E4%B8%80%E7%AF%87%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[这是我的第一篇博客文章,虽然弄的很垃圾,但是也勉强把私人博客弄起来了.期待以后的写作.]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇随感]]></title>
    <url>%2F2019%2F06%2F20%2F%E7%AC%AC%E4%B8%80%E7%AF%87%E9%9A%8F%E6%84%9F%2F</url>
    <content type="text"><![CDATA[用这个博客工具还是挺有意思的, 虽然现在才会弄一点点, 连引用别人的文章之类的都没学会但是起码弄起来了, 挺感慨工作四年了都没想起弄个博客来记录日常工作的点点滴滴, 没进行自己的技术积累, 有一种荒废青春的感觉. 也是几天前才想起有弄个博客记录的必要, 因为儿子已经7个月, 生活的重担让我有了危机感,不能像刚毕业的那段日子一样每天得过且过, 需要拥有一点自己的优势, 得以在未来的工作中不被淘汰, 给我自己的这个小家更多的支持. 在这里也感谢我的老婆给与我奋发向前的动力. 在以后的日子里, 这个博客会随着我的成长慢慢完善. 慢慢打造自己的小优势. ^_^]]></content>
      <tags>
        <tag>随感</tag>
      </tags>
  </entry>
</search>
