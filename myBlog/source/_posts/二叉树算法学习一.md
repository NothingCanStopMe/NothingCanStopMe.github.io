---
layout: 笔记
title: 二叉树算法学习一
date: 2019-12-25 20:34:13
tags: 笔记
---

顾名思义, 二叉树结构就是一个结点上面最多有两个子节点的树状数据结构. 节点有左右次序之分.
树结构数据有一些专有名词:

{% link "来源 百度百科" https://baike.baidu.com/item/二叉树/1602879?fr=aladdin %}
{% asset_img image/binaryMap1.jpg "图片来源百度百科" %}

结点层: 根结点的层定义为1, 根结点的孩子节点为2, 以此类推
树的深度: 树中最大的结点层
结点的度: 结点的子结点的个数
树的度: 树中最大的结点度
叶子结点: 也叫终端结点, 是度为0的结点
分枝结点: 度不为0的结点
有序树: 子树有序的树
无序树: 不考虑子树的顺序

二叉树的性质:
1. 在非空二叉树中, 第i层的结点数不超过math.pow(2, i-1), i>=1
2. 深度为h的二叉树最多有math.pow(2, h - 1)个结点, 最少有h个结点
(剩下的特性自己去百度看了...)

二叉树结点的数据结构:
链表存储方式的结构, 不能直接拿到结点的数据, 需要一个一个的搜索
{% codeblock %}
local bitNode = {
	data = xxx, -- 结点中存放的数据
	lChild = bitNode, -- 左边子结点
	rChild = bitNode, -- 右边子结点
	parent = parent, -- 父结点(根结点的父结点为空)
}
{% endcodeblock %}

递归生成二叉树数据的方法:
{% codeblock %}
-- bTree 生成的二叉树数据的table
-- treeCount 需要生成深度为多少的二叉树
function createBitNode(bTree, nodeCount, parent)
	if nodeCount > 0 then 
		bTree.data = nodeCount
		bTree.lChild = {}
		bTree.rChild = {}
		bTree.parent = parent
		createBitNode(bTree.lChild, nodeCount - 1, bTree)
		createBitNode(bTree.rChild, nodeCount - 1, bTree)
	end
end

local bTree = {}
local nodeCount = 3
createBitNode(bTree, nodeCount)

{% endcodeblock %}

一般来说, 遍历二叉树结构的方法有三种, 先序遍历(DLR), 中序遍历(LDR), 后序遍历
区别在于操作根节点的数据(data)的顺序
先序遍历:
{% codeblock %}
function preTreeParse(bTree)
	-- 这里只是用data字段是否有值来判断结点是否为空, 正常情况下用next(bTree)判断就好
	if bTree.data then 
		print(bTree.data)
		preTreeParse(bTree.lChild)
		preTreeParse(bTree.rChild)
	end
end

preTreeParse(bTree)
{% endcodeblock %}

中序遍历:
{% codeblock %}
function midTreeParse(bTree)
	-- 这里只是用data字段是否有值来判断结点是否为空, 正常情况下用next(bTree)判断就好
	if bTree.data then 
		midTreeParse(bTree.lChild)
		print(bTree.data)
		midTreeParse(bTree.rChild)
	end
end

midTreeParse(bTree)
{% endcodeblock %}

后序遍历

{% codeblock %}
function lastTreeParse(bTree)
	-- 这里只是用data字段是否有值来判断结点是否为空, 正常情况下用next(bTree)判断就好
	if bTree.data then 
		lastTreeParse(bTree.lChild)
		lastTreeParse(bTree.rChild)
		print(bTree.data)
	end
end

lastTreeParse(bTree)
{% endcodeblock %}
