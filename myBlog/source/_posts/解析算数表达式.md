---
layout: 笔记
title: 解析算数表达式
date: 2020-02-13 11:51:42
tags: 笔记
---

如何去解析一个算数表达式, 根据网上的解决方案, 用最基础的后缀表达式的方式实现.
过程如下:
1. 将中缀表达式(也就是常用的 a + b这一类将算数符号放在中间的) 转换为后缀表达式(ab+ 算数符号放在后面的)
2. 计算后缀表达式

为什么采取后缀表达式，因为没有括号, 注意没有括号.
先实现一个栈方法:
{% codeblock %}

local Stack = {}
function Stack:new()
	local ret = {}
	setmetatable(ret, {__index = self})
	ret:ctor()
	return ret
end

function Stack:ctor()
	self._length = 0
	self._capacity = {}
end

function Stack:push(value)
	self._length = self._length + 1
	table.insert(self._capacity, value)
end

function Stack:isEmpty()
	return self._length == 0
end

function Stack:pop()
	self._length = self._length - 1
	return table.remove(self._capacity)
end

function Stack:remove()
	self._length = self._length - 1
	table.remove(self._capacity, self._length)
end

function Stack:front()
	return self._capacity[self._length]
end

function Stack:clear()
	self._capacity = {}
	self._length = 0
end

function Stack:size()
	return self._length
end

{% endcodeblock %}

再实现将中缀表达式转换为后缀表达式
{% codeblock %}
-- 将中缀表达式转为后缀表达式的方法
local TransOper = {}

function TransOper:new(...)
	local ret = {}
	setmetatable(ret, {__index = self})
	ret:ctor(...)
	return ret
end

function TransOper:ctor(str)
	self.tranStr = str
	self.myStack = Stack:new()
	self.resultTab = {}
end

-- 开始将中缀表达式转为后缀表达式
function TransOper:doTrans()
	-- 将表达式分解为数字或运算符
	local index = 1
	local length = #self.tranStr
	while(index <= length) do
		local startIndex, endIndex = self.tranStr:find("[%d%.]+", index)
		if startIndex == index then 
			local str = self.tranStr:sub(startIndex, endIndex)
			index = endIndex + 1
			self:parseChar(str)
		else
			local startIndex, endIndex = self.tranStr:find("[%+%-%*%/%(%)]", index)
			local str = self.tranStr:sub(startIndex, endIndex)
			index = endIndex + 1
			self:parseChar(str)
		end
	end

	-- 如果栈里面还有运算符 那放再最后面
	while(self.myStack:isEmpty() == false) do
		local opTop = self.myStack:pop()
		table.insert(self.resultTab, opTop)
	end
end

function TransOper:parseChar(str)
	if str == "+" then 
		self:gotOper(str, 1)
	elseif str == "-" then 
		self:gotOper(str, 1)
	elseif str == "*" then 
		self:gotOper(str, 2)
	elseif str == "/" then 
		self:gotOper(str, 2)
	elseif str == "(" then 
		self.myStack:push(str)
	elseif str == ")" then 
		self:getParent(str)
	else
		table.insert(self.resultTab, str)
	end
end

-- 处理操作
function TransOper:gotOper(opThis, level)
	while(self.myStack:isEmpty() == false) do
		local opTop = self.myStack:pop()
		if opTop == nil then 
			table.insert(self.myStack, opThis)
			break
		else
			local preLevel = 0
			if opTop == "+" or opTop == "-" then 
				preLevel = 1
			elseif opTop == "*" or opTop == "/" then
				preLevel = 2
			end

			if preLevel < level then 
				self.myStack:push(opTop)
				break
			else
				table.insert(self.resultTab, opTop)
			end
		end
	end

	self.myStack:push(opThis)
end

function TransOper:getParent(opThis)
	while(self.myStack:isEmpty() == false ) do
		local opTop = self.myStack:pop()
		if opTop == "(" then 
			break
		else
			table.insert(self.resultTab, opTop)
		end
	end
end

function TransOper:getResult()
	return table.concat(self.resultTab, " ")
end

function TransOper:getResultTab()
	return self.resultTab
end
{% endcodeblock %}

然后计算后缀表达式的结果

{% codeblock %}
-- 计算后缀表达式的结果
local ComputeStuffix = {}
function ComputeStuffix:new(...)
	local ret = {}
	setmetatable(ret, {__index = self})
	ret:ctor(...)
	return ret
end

-- tab: 用上面后缀解析方法解析出来的表达式
function ComputeStuffix:ctor(tab)
	self.expressionTab = tab
	self.myStack = Stack:new()
	self.baseSymbols = {
		["+"] = true, 
		["-"] = true, ["*"] = true, ["/"] = true
	}
end

-- 是否基础运算符
function ComputeStuffix:isSymbol(symbol)
	return self.baseSymbols[symbol]
end

-- 开始计算
function ComputeStuffix:doCompute()
	for k,v in ipairs(self.expressionTab) do
		if not self:isSymbol(v) then 
			self.myStack:push(v)
		else
			self:doOper(v)
		end
	end
end

-- 计算具体的运算符
function ComputeStuffix:doOper(opThis)
	if self.myStack:size() <= 1 then 
		print("error your expressin is wrong!")
		print("error your expressin is wrong!")
		print("error your expressin is wrong!")
		return 
	end

	
	local pop1 = tonumber(self.myStack:pop())
	local pop2 = tonumber(self.myStack:pop())
	local result = 0
	if opThis == "+" then 
		result = pop2 + pop1
	elseif opThis == "-" then
		result = pop2 - pop1
	elseif opThis == "*" then 
		result = pop2 * pop1
	elseif opThis == "/" then 
		result = pop2 * pop1
	end
	self.myStack:push(result)

	print("longma doOper ", opThis, result)
end

function ComputeStuffix:getResult()
	return self.myStack:pop()
end

{% endcodeblock %}

最后写个测试
{% codeblock %}
local str = "15 * (25 + 15) + 2222 - 34 * ( 22 - 11)"
str = str:gsub(" ", "")

-- 直接用Lua的load方法最快啦...
local baseResult = load("return " .. str)()
local _transOper = TransOper:new(str)
_transOper:doTrans()
local out = _transOper:getResult()
print(out)

local compute = ComputeStuffix:new(_transOper:getResultTab())
compute:doCompute()
print(compute:getResult(), baseResult)

{% endcodeblock %}

{% link "参考自这位同学的简书" https://www.jianshu.com/p/dcf715a78f66 %}